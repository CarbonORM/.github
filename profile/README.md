# Welcome to [CarbonORM](https://carbonorm.dev/) ðŸ‘‹

The CarbonORMs are sometimes called C6 since Carbon is the sixth element in the Periodic Table. We aim to enable developers to query SQL in their middleware and frontend in a safe, constant, and syntactically pleasing way. Our Rest-based ORM auto-generates 1-1 type references to your tables and columns in JavaScript, TypeScript, and your middleware language (PHP, JAVA, PYTHON, C#, ...). We are still working to support all major languages, and help is very much welcome! Payloads between the frontend and middleware are JSON based, and working with SQL in your middle will use objects and array language-specific datatypes. Our generated C6 typings ensure a few things:

1. If you change a column name, everywhere in your project that uses the column can be found and changed. Attempting to access the old value would cause an invalid reference error.
2. Ensure invalid external column references raise an Error in the middleware, not the backend SQL server.
3. Type definitions allow your editors to make better coding suggestions.
4. Teams of developers can ensure that the SQL data schema stays up-to-date with each other. We have identified general change rules that allow CarbonORM to update projects on different servers or databases automagically. Some examples include auto-creating columns, primary and foreign key references, and changing column types. CarbonORM has also standardized where making advanced table updates should be placed. When changes exist that cannot be deterministically automated by us, an error will be thrown!
5. Large organizations with a frontend and backend team separated will not see the timing issues typical projects face. Generally, most operations can be done using a single table, and all connections are already generated to interface from the front end; front-end teams will not have to wait for the backend to create the necessary routes required for new features. This leaves backend teams focusing on validations rather than boilerplate and the frontend without bottlenecks. 

## Removing the risk of SQL injection entirely with [prepared statements](https://owasp.org/www-community/attacks/SQL_Injection)

Most languages support prepared statements, but the boilerplate code becomes repetitive in large projects. C6 is a response to the recognition that the likelihood of a mistake will skyrocket when developers must do mind-numbingly mundane repetitions. We eliminate the need for repetition by looping through these data structures and validating against our auto-generated code data definitions.

### How do we stop arbitrary SQL execution? (frontend testing is now necessary)

In local environments, we don't ;) This allows front-end engineers to move quickly. In our CI/CD pipelines, the frontend tests will quietly store all prepared statements it queried during the test. Our ORM conveniently provides this information with every request. After every test completes, C6 will compile these 'Valid SQL procedures' into a single object that the middleware will use for its validation in non-local environments. Any SQL executed from the frontend not existing in our valid SQL array will be logged and rejected. 

### Autogenerated with persistence!

While editing generated code is typically insufficient, we look to change this common practice. We believe there is no better place to put restful helper methods than the table class they operate on. We use custom complex regexes to capture these custom methods and persist them from revision to revision. We are pleased about how seamlessly this works and improves the DevOps experience. 

#### Finegrane control using hooks

It's possible to process complex Transactional code, kill a request based on the SQL generated, validate a column and its arguments each time it is processed, preprocess the request before the rest code is run, run global validations on every column encountered, rollback a transaction based on the results of a query, and even more possibilities. 

#### Transactions and Table Locking

Queries can be locked using [MySQL InnoDB ^8](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html) `FOR UPDATE` and `FOR SHARE,` which we can be used by adding `self::LOCK => self::FOR_UPDATE,` and `self::LOCK => self::FOR_SHARE` to the query body.

## Frontend to Backend JSON Syntax

As C6-enabled SQL queries are just objects and arrays, queries can be stored and abstracted in variables or constants and modified without string manipulation. Hooray! Middleware languages have varying syntax for representing these datatypes. To view language-specific examples for middleware queries, please check out the CarbonORM/Carbon<Middleware> repository, where <Middleware> is your language. We will use the standard frontend JavaScript (TypeScript) syntax for our examples here:

### GET (SELECT) 
#### SIMPLE
Here is an [open-source](https://github.com/Drop-In-Gaming/node-core/blob/main/packages/core/src/api/rest/getGameList.tsx) example from my time at [Drop-In Gaming](https://github.com/Drop-In-Gaming). Though full examples are available at the associated links, the following are stripped of imports.
`getGameList.tsx`
```TypeScript
export default restApi<{}, iDig_Chat_Global_Messages, {}, iGetC6RestResponse<iDig_Chat_Global_Messages>>({
    axios: DropVariables.axios,
    tableName: C6.dig_chat_global_messages.TABLE_NAME,
    requestMethod: GET,
    queryCallback: {
        [C6.SELECT]: [
            dig_chat_global_messages.GLOBAL_MESSAGE_ID,
            dig_chat_global_messages.GLOBAL_MESSAGE_FROM_USER,
            dig_chat_global_messages.GLOBAL_MESSAGE,
            dig_chat_global_messages.GLOBAL_MESSAGE_DATETIME,
            dig_chat_global_messages.GLOBAL_MESSAGE_ADVERTISEMENT,
            dig_chat_advertisements.ADVERTISEMENT_ACTIVE,
            dig_chat_advertisements.LAST_SHOWN_AT,
            [um_metadata.UM_VALUE, C6.AS, 'profile_photo'],
            users.DISPLAY_NAME,
            users.USER_NICENAME
        ],
        [C6.JOIN]: {
            [C6.INNER]: {
                [users.TABLE_NAME]: {
                    [dig_chat_global_messages.GLOBAL_MESSAGE_FROM_USER]: users.ID
                }
            },
            [C6.LEFT_OUTER]: {
                [um_metadata.TABLE_NAME]: {
                    [um_metadata.USER_ID]: users.ID,
                    [um_metadata.UM_KEY]: 'profile_photo',
                },
                [dig_chat_advertisements.TABLE_NAME]: {
                    [dig_chat_advertisements.ADVERTISEMENT_ID]: dig_chat_global_messages.GLOBAL_MESSAGE_ADVERTISEMENT
                }
            }
        },
        [C6.GROUP_BY]: [
            dig_chat_global_messages.GLOBAL_MESSAGE_ID,
            um_metadata.UM_VALUE
        ],
        [C6.PAGINATION]: {
            [C6.ORDER]: {
                [dig_chat_global_messages.GLOBAL_MESSAGE_DATETIME]: C6.DESC
            },
            [C6.PAGE]: 1,
            [C6.LIMIT]: 100
        },
    },
    responseCallback: response => {

        const restData = response?.data?.rest || [];

        DigApi.digApi.setState((previousState) => ({
            globalMessages: [...previousState.globalMessages || [], ...restData],
        }));

    }
})
```

Its [associated JEST test](https://github.com/Drop-In-Gaming/node-core/blob/main/packages/core/src/api/rest/getGameList.test.tsx) is even simpler.
`getGameList.test.tsx`
```TypeScript
describe('Get Games List', () => {

    test('Asset Game List Not Empty', async () => {

        let bootstrap: DigApi = DigApi.digApi;

        // @link https://reactjs.org/link/wrap-tests-with-act
        await act(async () => {

            /* fire events that update state */
            await getGameList();

            expect(bootstrap.state.backendThrowable).toEqual([]);

            expect(bootstrap.state.games).not.toBeNull();

            expect(bootstrap.state.games).not.toBeUndefined();

        });

        expect(bootstrap.state.games?.length).toBeGreaterThan(12)

    }, 31000);

});
```

### DELETE

See the [full example here](https://github.com/Drop-In-Gaming/node-core/blob/main/packages/core/src/api/rest/deleteFeatureGroupReference.tsx).

`deleteFeatureGroupReference.tsx`
```TypeScript
export default restApi<{
    featureId: number,
    groupId: number
}, iDig_Feature_Group_References, {}, iDeleteC6RestResponse>({
    axios: DropVariables.axios,
    tableName: C6.dig_feature_group_references.TABLE_NAME,
    requestMethod: DELETE,
    queryCallback: (request) => {
        request.success = 'Successfully deleted the feature from the group.'
        request.error = 'Failed to remove the feature from the group. Please try again later.'
        return {
            [C6.WHERE]: {
                [C6.dig_feature_group_references.FEATURE_ENTITY_ID]: request.featureId,
                [C6.dig_feature_group_references.GROUP_ENTITY_ID]: request.groupId,
            }
        }
    },
    responseCallback: (_response, request, id) => {

        id && updateRestfulObjectArray<iGroups>((previousState) => {

            const fullGroup: iGroups | undefined = previousState.groups?.find((group: iGroups) => group.entity_id === request.groupId);

            const fullFeature: iDig_Features | undefined = previousState.features?.find((feature: iDig_Features) => feature.feature_entity_id === request.featureId);

            const index : number|undefined = fullGroup?.feature_code?.indexOf(fullFeature?.feature_code ?? '');

            if (index && index > -1) { // only splice array when item is found
                fullGroup?.feature_code?.splice(index, 1); // 2nd parameter means remove one item only
            }

            return fullGroup ? [fullGroup] : [];

        }, "entity_id", "groups")

    }
});
```

### PUT (UPDATE)

The code directly blow is executing a change using the `requestMethod: PUT,`.

```TypeScript
await putUser({
    ID: myUser?.id,
    user_email: 'example@example.com'
})
```

The full code blow can be [found here](https://github.com/Drop-In-Gaming/node-core/blob/main/packages/core/src/api/rest/putUser.tsx).
`putUser.tsx`
```TypeScript
export default restApi<{ ID: number }, iUsers,{}, iPutC6RestResponse<iUsers>>({
    axios: DropVariables.axios,
    tableName: C6.users.TABLE_NAME,
    requestMethod: PUT,
    queryCallback: (request) => {
        request.success = 'Successfully updated user information!'
        request.error = 'An error occurred while updating user information!'
        return request
    },
    responseCallback: (response, request) => {

        console.log('response from', response)

        if (undefined !== request.user_pass) {

            return;

        }

        updateRestfulObjectArray<iUsers>([removeInvalidKeys(request, [users])], "ID", "users");

    }

});
```

### POST (INSERT)

The [registration example](https://github.com/Drop-In-Gaming/node-core/blob/main/sites/gh-pages/src/examples/RegisterApi.tsx).

```TypeScript
postUser({
    user_login: userSignUpAndInInformation.user_login,
    user_email: userSignUpAndInInformation.user_email,
    user_birthday: dateOfBirth,
    organization_id: organization_id,
    success: () => {
        return 'Account created!'  // this will appear in a toast notification
    }
}).then(axiosResponse => console.log(axiosResponse))
  .error(error => console.log(error))
```
The promise returned by the example above does not need to be awaited as the responseCallback in the code below is usually responcible for handing the initial parsing and placed into state.

The gerneral [code](https://github.com/Drop-In-Gaming/node-core/blob/main/packages/core/src/api/rest/postUser.tsx) below.

```TypeScript
export default restApi<iPostUser, iUsers & iDig_Temp_Invite & iDig_Parent_User & iDig_User_Info & iDig_User_Organizations, {}, iPostC6RestResponse<iUsers>>({
    axios: DropVariables.axios,
    tableName: [C6.users.TABLE_NAME, C6.dig_temp_invite.TABLE_NAME, C6.dig_parent_user.TABLE_NAME, C6.dig_user_info.TABLE_NAME, C6.dig_user_organizations.TABLE_NAME, ],
    requestMethod: POST,
    queryCallback: (request) => {
        request.success ??= 'Successfully created your account! You may now log in using your new credentials.'
        request.error = 'An unknown issue occurred while creating your account.'
        return request
    },
    responseCallback: (_response, request, id) => {
        // ... responseCallback code here ...
    }

});
```


## How does autogenerating the definitions work?

Remember that the business logic is shared; all that is needed is class (object) files with the necessary column data; usually presented as constants. We provide an array with a breakdown of types, foreign key references, and column-specific information. Our editable generations include these class variables: a map for column => regex validation, a complex map used for assigning callable functions to column/validation rest query hooks, and finally, a simple array of callables filled with complex SQL database update procedures. 

1. We generate a [Data Definition Language (DDL)](https://en.wikipedia.org/wiki/Data_definition_language) file using common tools like [`mysqldump`](https://dev.mysql.com/doc/refman/8.0/en/mysqldump-definition-data-dumps.html).
2. Parse this data using regex or string manipulation and output the data types for JavaScript/Typescript and the Middleware language.
3. Profit.

You can view a generated table file (carbon_users) which includes custom user methods that will persist across regeneration at my open-source php starter template [CarbonORM/CarbonReactBootstrap](https://github.com/CarbonORM/CarbonReactBootstrap/blob/main/backend/tables/Users.php).


